// 1. DosyalarÄ± aÃ§
// 2. pipe() oluÅŸtur
// 3. fork() ile child1
//      dup2(infile, stdin)
//      dup2(pipe_write, stdout)
//      execve(cmd1)
// 4. fork() ile child2
//      dup2(pipe_read, stdin)
//      dup2(outfile, stdout)
//      execve(cmd2)
// 5. Parent process
//      waitpid(child1)
//      waitpid(child2)
//      dosya ve pipe kapat


Elbette! Åimdi sana **Pipex projesinin tamamÄ±nÄ±**, hem **mandatory** hem de **bonus** kÄ±smÄ±nÄ± kapsayacak ÅŸekilde, **baÅŸlangÄ±Ã§tan sonuna kadar** sistemli ve sade bir ÅŸekilde Ã¶zetleyeceÄŸim. Sanki kendin projeyi yeni yapacakmÄ±ÅŸsÄ±n gibi dÃ¼ÅŸÃ¼n.

---

# ğŸ§ª 42 Pipex Projesi - BAÅTAN SONA Ã–ZET

---

## ğŸ“Œ AMAÃ‡

Shell'deki ÅŸu komutu:

```bash
< infile cmd1 | cmd2 > outfile
```

C dilinde yeniden yazmak.

ProgramÄ±n ÅŸu ÅŸekilde Ã§alÄ±ÅŸacak:

```bash
./pipex infile "cmd1 args" "cmd2 args" outfile
```

> Bonus kÄ±smÄ±nda:

```bash
./pipex here_doc LIMITER cmd1 cmd2 ... cmdn outfile
```

---

## ğŸ“ DOSYA YAPISI Ã–NERÄ°SÄ°

```bash
pipex/
â”œâ”€â”€ main.c              // argÃ¼man kontrolÃ¼ ve mod belirleme
â”œâ”€â”€ pipex.h             // header dosyasÄ±
â”œâ”€â”€ arg_check.c         // argÃ¼man kontrol fonksiyonu
â”œâ”€â”€ execute_cmd.c       // execve ile komut Ã§alÄ±ÅŸtÄ±ran fonksiyon
â”œâ”€â”€ path_utils.c        // PATH Ã§Ã¶zÃ¼mleme (envp'den)
â”œâ”€â”€ here_doc.c          // here_doc bonus Ã¶zelliÄŸi
â”œâ”€â”€ utils.c             // hata ve cleanup fonksiyonlarÄ±
â””â”€â”€ Makefile
```

---

## âœ… 1. `main.c` â€“ BaÅŸlangÄ±Ã§ noktasÄ±

### GÃ¶revleri:

* ArgÃ¼man sayÄ±sÄ±nÄ± kontrol eder (`arguman_check`)
* Bonus mu, mandatory mi ayÄ±rÄ±r (`strcmp(argv[1], "here_doc")`)
* DoÄŸru moda gÃ¶re fonksiyona yÃ¶nlendirir (`start_here_doc()` / `start_pipex()`)

---

## âœ… 2. `arguman_check.c` â€“ ArgÃ¼manlarÄ± doÄŸrula

### Ne kontrol edilmeli?

| Kontrol                             | Zorunlu?  |
| ----------------------------------- | --------- |
| ArgÃ¼man sayÄ±sÄ± yeterli mi           | âœ…         |
| `"here_doc"` modundaysa `argc >= 6` | âœ…         |
| Komutlar boÅŸ mu (`""`)              | Opsiyonel |
| `infile` okunabilir mi              | Opsiyonel |

---

## âœ… 3. `start_pipex()` â€“ Ana Pipex Fonksiyonu (mandatory)

### Ne yapar?

1. `open()` ile `infile` ve `outfile` dosyalarÄ±nÄ± aÃ§ar.
2. `pipe()` ile pipe oluÅŸturur.
3. `fork()` ile 2 child process baÅŸlatÄ±r:

   * **Child 1:** `infile` â†’ `cmd1` â†’ `pipe`
   * **Child 2:** `pipe` â†’ `cmd2` â†’ `outfile`
4. Her child process:

   * `dup2()` ile yÃ¶nlendirme yapar (stdin/stdout)
   * `execve()` ile komutu Ã§alÄ±ÅŸtÄ±rÄ±r
5. Parent:

   * Pipe ve dosyalarÄ± kapatÄ±r.
   * `waitpid()` ile Ã§ocuklarÄ± bekler.

---

## âœ… 4. `execute_cmd()` â€“ Komutu Ã§alÄ±ÅŸtÄ±r

### AdÄ±mlar:

1. `ft_split()` ile `"ls -l"` â†’ `["ls", "-l", NULL]`
2. `envp`'den `PATH` deÄŸiÅŸkenini bul.
3. `PATH` iÃ§indeki her klasÃ¶rde `cmd` var mÄ± `access()` ile kontrol et.
4. `execve(full_path, args, envp);`
5. BaÅŸarÄ±sÄ±z olursa `perror()` + `exit(EXIT_FAILURE)`

---

## âœ… 5. `path_utils.c` â€“ Komut yolu bulma

### GÃ¶revleri:

* `envp`'de `PATH=` satÄ±rÄ±nÄ± bul
* `:` ile bÃ¶l, Ã¶rn: `["/usr/bin", "/bin", ...]`
* `cmd` ile birleÅŸtir: `"/usr/bin/ls"` gibi
* `access(path, X_OK)` ile Ã§alÄ±ÅŸtÄ±rÄ±labilir mi kontrol et
* Ä°lk Ã§alÄ±ÅŸan yolu dÃ¶ndÃ¼r

---

## âœ… 6. `here_doc.c` â€“ Bonus Ã–zellik

### Ne yapar?

```bash
./pipex here_doc LIMITER cmd1 cmd2 ... cmdN outfile
```

1. `here_doc` kelimesi varsa bu moda geÃ§
2. `limiter` gelene kadar kullanÄ±cÄ±dan stdin okur
3. GeÃ§ici dosyaya yazar (`.heredoc_tmp`)
4. Bu dosyayÄ± `infile` gibi kullan
5. `outfile` dosyasÄ±nÄ± `O_APPEND` ile aÃ§ar
6. `unlink()` ile geÃ§ici dosyayÄ± silmeyi unutma

---

## âœ… 7. `utils.c` â€“ YardÄ±mcÄ± Fonksiyonlar

### Fonksiyonlar:

* `print_error()` â†’ `perror()` + `exit()`
* `free_split()` â†’ `char **split` belleklerini temizler

---Genelde bu tÃ¼r bir durumda hatanÄ±n sebepleri ÅŸunlardan biri olur:

    abc.txt dosyasÄ± mevcut deÄŸil â†’ open() hatasÄ± alÄ±rsÄ±n.

    execve sÄ±rasÄ±nda komut bulunamÄ±yor â†’ Ã¶rn. "grep a" yanlÄ±ÅŸ biÃ§imlendirilmiÅŸ.

    pipe veya dup2 iÅŸlemlerinde yanlÄ±ÅŸ file descriptor kullanÄ±mÄ±.

    malloc sonucu bellek sÄ±zÄ±ntÄ±sÄ± veya geÃ§ersiz eriÅŸim.


## âš™ï¸ KULLANILACAK SÄ°STEM FONKSÄ°YONLARI

| Kategori         | Fonksiyonlar                        |
| ---------------- | ----------------------------------- |
| Dosya iÅŸlemleri  | `open`, `close`, `unlink`, `access` |
| Bellek iÅŸlemleri | `malloc`, `free`                    |
| Process yÃ¶netimi | `fork`, `wait`, `waitpid`, `execve` |
| I/O yÃ¶nlendirme  | `pipe`, `dup2`, `read`, `write`     |
| Hata yÃ¶netimi    | `perror`, `strerror`, `exit`        |

---

## ğŸ’¡ TEST Ã–RNEKLERÄ°

```bash
$> ./pipex infile "grep a" "wc -l" outfile
$> ./pipex here_doc LIMITER "cat" "wc -c" outfile
```

---

## âœ… MAKEFILE

```makefile
NAME = pipex

CC = cc
CFLAGS = -Wall -Wextra -Werror

SRCS = main.c arg_check.c execute_cmd.c path_utils.c utils.c pipex.c
BONUS = here_doc.c

OBJS = $(SRCS:.c=.o)

all: $(NAME)

$(NAME): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) -o $(NAME)

bonus:
	$(CC) $(CFLAGS) $(SRCS) $(BONUS) -o $(NAME)

clean:
	rm -f $(OBJS)

fclean: clean
	rm -f $(NAME)

re: fclean all
```

---

## ğŸ”š Ã–ZETLE

| AÅŸama                    | AÃ§Ä±klama                               |
| ------------------------ | -------------------------------------- |
| âœ… ArgÃ¼manlarÄ± kontrol et | `arguman_check()`                      |
| âœ… Pipe oluÅŸtur           | `pipe()`                               |
| âœ… Process yarat          | `fork()`                               |
| âœ… I/O yÃ¶nlendirme        | `dup2()`                               |
| âœ… Komutu Ã§alÄ±ÅŸtÄ±r        | `execve()`                             |
| âœ… Bekle ve temizle       | `waitpid()`, `close()`                 |
| âœ… Bonus iÃ§in here\_doc   | `stdin`'den oku, tmp dosya, `O_APPEND` |

---

## ğŸ”§ YardÄ±mcÄ± OlabileceÄŸim DiÄŸer Åeyler

* Fonksiyon fonksiyon birlikte yazmak
* `execute_cmd()`'i adÄ±m adÄ±m yapmak
* `here_doc` kodunu Ã¶rneklemek
* Test scripti oluÅŸturmak

HazÄ±rsan bir sonraki adÄ±ma geÃ§elim:
ğŸ‘‰ Ne yazmak istersin ÅŸimdi? `main.c`, `execute_cmd()`, `path Ã§Ã¶zÃ¼mÃ¼`?
